import{bf as _e,bg as Oe,bh as qe,bi as Ft,bj as Ne,bk as $e,bl as le,bm as St}from"./index-f91fdf80.js";class ue extends _e{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Oe(n);const r=qe(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let f=0;f<o.length;f++)o[f]^=54;this.iHash.update(o),this.oHash=n.create();for(let f=0;f<o.length;f++)o[f]^=106;this.oHash.update(o),o.fill(0)}update(n){return Ft(this),this.iHash.update(n),this}digestInto(n){Ft(this),Ne(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:f,outputLen:c}=this;return n=n,n.finished=s,n.destroyed=o,n.blockLen=f,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const de=(t,n,e)=>new ue(t,n).update(e).digest();de.create=(t,n)=>new ue(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=BigInt(0),qt=BigInt(1),Re=BigInt(2);function ft(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function W(t){if(!ft(t))throw new Error("Uint8Array expected")}function gt(t,n){if(typeof n!="boolean")throw new Error(`${t} must be valid boolean, got "${n}".`)}const Te=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function wt(t){W(t);let n="";for(let e=0;e<t.length;e++)n+=Te[t[e]];return n}function dt(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Mt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const X={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function te(t){if(t>=X._0&&t<=X._9)return t-X._0;if(t>=X._A&&t<=X._F)return t-(X._A-10);if(t>=X._a&&t<=X._f)return t-(X._a-10)}function mt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const f=te(t.charCodeAt(o)),c=te(t.charCodeAt(o+1));if(f===void 0||c===void 0){const i=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+o)}r[s]=f*16+c}return r}function G(t){return Mt(wt(t))}function Kt(t){return W(t),Mt(wt(Uint8Array.from(t).reverse()))}function ot(t,n){return mt(t.toString(16).padStart(n*2,"0"))}function Yt(t,n){return ot(t,n).reverse()}function Le(t){return mt(dt(t))}function U(t,n,e){let r;if(typeof n=="string")try{r=mt(n)}catch(o){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${o}`)}else if(ft(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${t} expected ${e} bytes, got ${s}`);return r}function P(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];W(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}function He(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function Nt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}const Tt=t=>typeof t=="bigint"&&jt<=t;function yt(t,n,e){return Tt(t)&&Tt(n)&&Tt(e)&&n<=t&&t<e}function rt(t,n,e,r){if(!yt(n,e,r))throw new Error(`expected valid ${t}: ${e} <= n < ${r}, got ${typeof n} ${n}`)}function he(t){let n;for(n=0;t>jt;t>>=qt,n+=1);return n}function Ze(t,n){return t>>BigInt(n)&qt}function ke(t,n,e){return t|(e?qt:jt)<<BigInt(n)}const Dt=t=>(Re<<BigInt(t-1))-qt,Lt=t=>new Uint8Array(t),ee=t=>Uint8Array.from(t);function ge(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Lt(t),s=Lt(t),o=0;const f=()=>{r.fill(1),s.fill(0),o=0},c=(...w)=>e(s,r,...w),i=(w=Lt())=>{s=c(ee([0]),w),r=c(),w.length!==0&&(s=c(ee([1]),w),r=c())},l=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let w=0;const d=[];for(;w<n;){r=c();const v=r.slice();d.push(v),w+=r.length}return P(...d)};return(w,d)=>{f(),i(w);let v;for(;!(v=d(l()));)i();return f(),v}}const Ue={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||ft(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function bt(t,n,e={}){const r=(s,o,f)=>{const c=Ue[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const i=t[s];if(!(f&&i===void 0)&&!c(i,t))throw new Error(`Invalid param ${String(s)}=${i} (${typeof i}), expected ${o}`)};for(const[s,o]of Object.entries(n))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return t}const Ce=()=>{throw new Error("not implemented")};function Ut(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(s!==void 0)return s;const o=t(e,...r);return n.set(e,o),o}}const Ve=Object.freeze(Object.defineProperty({__proto__:null,aInRange:rt,abool:gt,abytes:W,bitGet:Ze,bitLen:he,bitMask:Dt,bitSet:ke,bytesToHex:wt,bytesToNumberBE:G,bytesToNumberLE:Kt,concatBytes:P,createHmacDrbg:ge,ensureBytes:U,equalBytes:He,hexToBytes:mt,hexToNumber:Mt,inRange:yt,isBytes:ft,memoized:Ut,notImplemented:Ce,numberToBytesBE:ot,numberToBytesLE:Yt,numberToHexUnpadded:dt,numberToVarBytesBE:Le,utf8ToBytes:Nt,validateObject:bt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const k=BigInt(0),L=BigInt(1),ct=BigInt(2),ze=BigInt(3),Ct=BigInt(4),ne=BigInt(5),re=BigInt(8);BigInt(9);BigInt(16);function Z(t,n){const e=t%n;return e>=k?e:n+e}function Pe(t,n,e){if(e<=k||n<k)throw new Error("Expected power/modulo > 0");if(e===L)return k;let r=L;for(;n>k;)n&L&&(r=r*t%e),t=t*t%e,n>>=L;return r}function M(t,n,e){let r=t;for(;n-- >k;)r*=r,r%=e;return r}function Vt(t,n){if(t===k||n<=k)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=Z(t,n),r=n,s=k,o=L;for(;e!==k;){const c=r/e,i=r%e,l=s-o*c;r=e,e=i,s=o,o=l}if(r!==L)throw new Error("invert: does not exist");return Z(s,n)}function je(t){const n=(t-L)/ct;let e,r,s;for(e=t-L,r=0;e%ct===k;e/=ct,r++);for(s=ct;s<t&&Pe(s,n,t)!==t-L;s++);if(r===1){const f=(t+L)/Ct;return function(i,l){const h=i.pow(l,f);if(!i.eql(i.sqr(h),l))throw new Error("Cannot find square root");return h}}const o=(e+L)/ct;return function(c,i){if(c.pow(i,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let l=r,h=c.pow(c.mul(c.ONE,s),e),w=c.pow(i,o),d=c.pow(i,e);for(;!c.eql(d,c.ONE);){if(c.eql(d,c.ZERO))return c.ZERO;let v=1;for(let y=c.sqr(d);v<l&&!c.eql(y,c.ONE);v++)y=c.sqr(y);const q=c.pow(h,L<<BigInt(l-v-1));h=c.sqr(q),w=c.mul(w,q),d=c.mul(d,h),l=v}return w}}function Me(t){if(t%Ct===ze){const n=(t+L)/Ct;return function(r,s){const o=r.pow(s,n);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%re===ne){const n=(t-ne)/re;return function(r,s){const o=r.mul(s,ct),f=r.pow(o,n),c=r.mul(s,f),i=r.mul(r.mul(c,ct),f),l=r.mul(c,r.sub(i,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return je(t)}const Ke=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function we(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ke.reduce((r,s)=>(r[s]="function",r),n);return bt(t,e)}function Ye(t,n,e){if(e<k)throw new Error("Expected power > 0");if(e===k)return t.ONE;if(e===L)return n;let r=t.ONE,s=n;for(;e>k;)e&L&&(r=t.mul(r,s)),s=t.sqr(s),e>>=L;return r}function De(t,n){const e=new Array(n.length),r=n.reduce((o,f,c)=>t.is0(f)?o:(e[c]=o,t.mul(o,f)),t.ONE),s=t.inv(r);return n.reduceRight((o,f,c)=>t.is0(f)?o:(e[c]=t.mul(o,e[c]),t.mul(o,f)),s),e}function me(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function ye(t,n,e=!1,r={}){if(t<=k)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=me(t,n);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=Me(t),c=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:Dt(s),ZERO:k,ONE:L,create:i=>Z(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof i}`);return k<=i&&i<t},is0:i=>i===k,isOdd:i=>(i&L)===L,neg:i=>Z(-i,t),eql:(i,l)=>i===l,sqr:i=>Z(i*i,t),add:(i,l)=>Z(i+l,t),sub:(i,l)=>Z(i-l,t),mul:(i,l)=>Z(i*l,t),pow:(i,l)=>Ye(c,i,l),div:(i,l)=>Z(i*Vt(l,t),t),sqrN:i=>i*i,addN:(i,l)=>i+l,subN:(i,l)=>i-l,mulN:(i,l)=>i*l,inv:i=>Vt(i,t),sqrt:r.sqrt||(i=>f(c,i)),invertBatch:i=>De(c,i),cmov:(i,l,h)=>h?l:i,toBytes:i=>e?Yt(i,o):ot(i,o),fromBytes:i=>{if(i.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${i.length}`);return e?Kt(i):G(i)}});return Object.freeze(c)}function be(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Ee(t){const n=be(t);return n+Math.ceil(n/2)}function Ge(t,n,e=!1){const r=t.length,s=be(n),o=Ee(n);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const f=e?G(t):Kt(t),c=Z(f,n-L)+L;return e?Yt(c,s):ot(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const We=BigInt(0),Ht=BigInt(1),Zt=new WeakMap,oe=new WeakMap;function Xe(t,n){const e=(o,f)=>{const c=f.negate();return o?c:f},r=o=>{if(!Number.isSafeInteger(o)||o<=0||o>n)throw new Error(`Wrong window size=${o}, should be [1..${n}]`)},s=o=>{r(o);const f=Math.ceil(n/o)+1,c=2**(o-1);return{windows:f,windowSize:c}};return{constTimeNegate:e,unsafeLadder(o,f){let c=t.ZERO,i=o;for(;f>We;)f&Ht&&(c=c.add(i)),i=i.double(),f>>=Ht;return c},precomputeWindow(o,f){const{windows:c,windowSize:i}=s(f),l=[];let h=o,w=h;for(let d=0;d<c;d++){w=h,l.push(w);for(let v=1;v<i;v++)w=w.add(h),l.push(w);h=w.double()}return l},wNAF(o,f,c){const{windows:i,windowSize:l}=s(o);let h=t.ZERO,w=t.BASE;const d=BigInt(2**o-1),v=2**o,q=BigInt(o);for(let y=0;y<i;y++){const a=y*l;let u=Number(c&d);c>>=q,u>l&&(u-=v,c+=Ht);const g=a,b=a+Math.abs(u)-1,B=y%2!==0,O=u<0;u===0?w=w.add(e(B,f[g])):h=h.add(e(O,f[b]))}return{p:h,f:w}},wNAFCached(o,f,c){const i=oe.get(o)||1;let l=Zt.get(o);return l||(l=this.precomputeWindow(o,i),i!==1&&Zt.set(o,c(l))),this.wNAF(i,l,f)},setWindowSize(o,f){r(f),oe.set(o,f),Zt.delete(o)}}}function Qe(t,n,e,r){if(!Array.isArray(e)||!Array.isArray(r)||r.length!==e.length)throw new Error("arrays of points and scalars must have equal length");r.forEach((h,w)=>{if(!n.isValid(h))throw new Error(`wrong scalar at index ${w}`)}),e.forEach((h,w)=>{if(!(h instanceof t))throw new Error(`wrong point at index ${w}`)});const s=he(BigInt(e.length)),o=s>12?s-3:s>4?s-2:s?2:1,f=(1<<o)-1,c=new Array(f+1).fill(t.ZERO),i=Math.floor((n.BITS-1)/o)*o;let l=t.ZERO;for(let h=i;h>=0;h-=o){c.fill(t.ZERO);for(let d=0;d<r.length;d++){const v=r[d],q=Number(v>>BigInt(h)&BigInt(f));c[q]=c[q].add(e[d])}let w=t.ZERO;for(let d=c.length-1,v=t.ZERO;d>0;d--)v=v.add(c[d]),w=w.add(v);if(l=l.add(w),h!==0)for(let d=0;d<o;d++)l=l.double()}return l}function pe(t){return we(t.Fp),bt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...me(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ie(t){t.lowS!==void 0&&gt("lowS",t.lowS),t.prehash!==void 0&&gt("prehash",t.prehash)}function Je(t){const n=pe(t);bt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Fe,hexToBytes:tn}=Ve,Q={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(t,n)=>{const{Err:e}=Q;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=dt(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?dt(s.length/2|128):"";return`${dt(t)}${o}${s}${n}`},decode(t,n){const{Err:e}=Q;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++],o=!!(s&128);let f=0;if(!o)f=s;else{const i=s&127;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const l=n.subarray(r,r+i);if(l.length!==i)throw new e("tlv.decode: length bytes not complete");if(l[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const h of l)f=f<<8|h;if(r+=i,f<128)throw new e("tlv.decode(long): not minimal encoding")}const c=n.subarray(r,r+f);if(c.length!==f)throw new e("tlv.decode: wrong value length");return{v:c,l:n.subarray(r+f)}}},_int:{encode(t){const{Err:n}=Q;if(t<D)throw new n("integer: negative integers are not allowed");let e=dt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected assertion");return e},decode(t){const{Err:n}=Q;if(t[0]&128)throw new n("Invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return Fe(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=Q,s=typeof t=="string"?tn(t):t;W(s);const{v:o,l:f}=r.decode(48,s);if(f.length)throw new n("Invalid signature: left bytes after parsing");const{v:c,l:i}=r.decode(2,o),{v:l,l:h}=r.decode(2,i);if(h.length)throw new n("Invalid signature: left bytes after parsing");return{r:e.decode(c),s:e.decode(l)}},hexFromSig(t){const{_tlv:n,_int:e}=Q,r=`${n.encode(2,e.encode(t.r))}${n.encode(2,e.encode(t.s))}`;return n.encode(48,r)}},D=BigInt(0),$=BigInt(1),et=BigInt(2),At=BigInt(3),se=BigInt(4);function en(t){const n=Je(t),{Fp:e}=n,r=ye(n.n,n.nBitLength),s=n.toBytes||((y,a,u)=>{const g=a.toAffine();return P(Uint8Array.from([4]),e.toBytes(g.x),e.toBytes(g.y))}),o=n.fromBytes||(y=>{const a=y.subarray(1),u=e.fromBytes(a.subarray(0,e.BYTES)),g=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:u,y:g}});function f(y){const{a,b:u}=n,g=e.sqr(y),b=e.mul(g,y);return e.add(e.add(b,e.mul(y,a)),u)}if(!e.eql(e.sqr(n.Gy),f(n.Gx)))throw new Error("bad generator point: equation left != right");function c(y){return yt(y,$,n.n)}function i(y){const{allowedPrivateKeyLengths:a,nByteLength:u,wrapPrivateKey:g,n:b}=n;if(a&&typeof y!="bigint"){if(ft(y)&&(y=wt(y)),typeof y!="string"||!a.includes(y.length))throw new Error("Invalid key");y=y.padStart(u*2,"0")}let B;try{B=typeof y=="bigint"?y:G(U("private key",y,u))}catch{throw new Error(`private key must be ${u} bytes, hex or bigint, not ${typeof y}`)}return g&&(B=Z(B,b)),rt("private key",B,$,b),B}function l(y){if(!(y instanceof d))throw new Error("ProjectivePoint expected")}const h=Ut((y,a)=>{const{px:u,py:g,pz:b}=y;if(e.eql(b,e.ONE))return{x:u,y:g};const B=y.is0();a==null&&(a=B?e.ONE:e.inv(b));const O=e.mul(u,a),A=e.mul(g,a),x=e.mul(b,a);if(B)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:O,y:A}}),w=Ut(y=>{if(y.is0()){if(n.allowInfinityPoint&&!e.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:a,y:u}=y.toAffine();if(!e.isValid(a)||!e.isValid(u))throw new Error("bad point: x or y not FE");const g=e.sqr(u),b=f(a);if(!e.eql(g,b))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(a,u,g){if(this.px=a,this.py=u,this.pz=g,a==null||!e.isValid(a))throw new Error("x required");if(u==null||!e.isValid(u))throw new Error("y required");if(g==null||!e.isValid(g))throw new Error("z required");Object.freeze(this)}static fromAffine(a){const{x:u,y:g}=a||{};if(!a||!e.isValid(u)||!e.isValid(g))throw new Error("invalid affine point");if(a instanceof d)throw new Error("projective point not allowed");const b=B=>e.eql(B,e.ZERO);return b(u)&&b(g)?d.ZERO:new d(u,g,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const u=e.invertBatch(a.map(g=>g.pz));return a.map((g,b)=>g.toAffine(u[b])).map(d.fromAffine)}static fromHex(a){const u=d.fromAffine(o(U("pointHex",a)));return u.assertValidity(),u}static fromPrivateKey(a){return d.BASE.multiply(i(a))}static msm(a,u){return Qe(d,r,a,u)}_setWindowSize(a){q.setWindowSize(this,a)}assertValidity(){w(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){l(a);const{px:u,py:g,pz:b}=this,{px:B,py:O,pz:A}=a,x=e.eql(e.mul(u,A),e.mul(B,b)),S=e.eql(e.mul(g,A),e.mul(O,b));return x&&S}negate(){return new d(this.px,e.neg(this.py),this.pz)}double(){const{a,b:u}=n,g=e.mul(u,At),{px:b,py:B,pz:O}=this;let A=e.ZERO,x=e.ZERO,S=e.ZERO,I=e.mul(b,b),j=e.mul(B,B),T=e.mul(O,O),N=e.mul(b,B);return N=e.add(N,N),S=e.mul(b,O),S=e.add(S,S),A=e.mul(a,S),x=e.mul(g,T),x=e.add(A,x),A=e.sub(j,x),x=e.add(j,x),x=e.mul(A,x),A=e.mul(N,A),S=e.mul(g,S),T=e.mul(a,T),N=e.sub(I,T),N=e.mul(a,N),N=e.add(N,S),S=e.add(I,I),I=e.add(S,I),I=e.add(I,T),I=e.mul(I,N),x=e.add(x,I),T=e.mul(B,O),T=e.add(T,T),I=e.mul(T,N),A=e.sub(A,I),S=e.mul(T,j),S=e.add(S,S),S=e.add(S,S),new d(A,x,S)}add(a){l(a);const{px:u,py:g,pz:b}=this,{px:B,py:O,pz:A}=a;let x=e.ZERO,S=e.ZERO,I=e.ZERO;const j=n.a,T=e.mul(n.b,At);let N=e.mul(u,B),z=e.mul(g,O),m=e.mul(b,A),E=e.add(u,g),p=e.add(B,O);E=e.mul(E,p),p=e.add(N,z),E=e.sub(E,p),p=e.add(u,b);let _=e.add(B,A);return p=e.mul(p,_),_=e.add(N,m),p=e.sub(p,_),_=e.add(g,b),x=e.add(O,A),_=e.mul(_,x),x=e.add(z,m),_=e.sub(_,x),I=e.mul(j,p),x=e.mul(T,m),I=e.add(x,I),x=e.sub(z,I),I=e.add(z,I),S=e.mul(x,I),z=e.add(N,N),z=e.add(z,N),m=e.mul(j,m),p=e.mul(T,p),z=e.add(z,m),m=e.sub(N,m),m=e.mul(j,m),p=e.add(p,m),N=e.mul(z,p),S=e.add(S,N),N=e.mul(_,p),x=e.mul(E,x),x=e.sub(x,N),N=e.mul(E,z),I=e.mul(_,I),I=e.add(I,N),new d(x,S,I)}subtract(a){return this.add(a.negate())}is0(){return this.equals(d.ZERO)}wNAF(a){return q.wNAFCached(this,a,d.normalizeZ)}multiplyUnsafe(a){rt("scalar",a,D,n.n);const u=d.ZERO;if(a===D)return u;if(a===$)return this;const{endo:g}=n;if(!g)return q.unsafeLadder(this,a);let{k1neg:b,k1:B,k2neg:O,k2:A}=g.splitScalar(a),x=u,S=u,I=this;for(;B>D||A>D;)B&$&&(x=x.add(I)),A&$&&(S=S.add(I)),I=I.double(),B>>=$,A>>=$;return b&&(x=x.negate()),O&&(S=S.negate()),S=new d(e.mul(S.px,g.beta),S.py,S.pz),x.add(S)}multiply(a){const{endo:u,n:g}=n;rt("scalar",a,$,g);let b,B;if(u){const{k1neg:O,k1:A,k2neg:x,k2:S}=u.splitScalar(a);let{p:I,f:j}=this.wNAF(A),{p:T,f:N}=this.wNAF(S);I=q.constTimeNegate(O,I),T=q.constTimeNegate(x,T),T=new d(e.mul(T.px,u.beta),T.py,T.pz),b=I.add(T),B=j.add(N)}else{const{p:O,f:A}=this.wNAF(a);b=O,B=A}return d.normalizeZ([b,B])[0]}multiplyAndAddUnsafe(a,u,g){const b=d.BASE,B=(A,x)=>x===D||x===$||!A.equals(b)?A.multiplyUnsafe(x):A.multiply(x),O=B(this,u).add(B(a,g));return O.is0()?void 0:O}toAffine(a){return h(this,a)}isTorsionFree(){const{h:a,isTorsionFree:u}=n;if(a===$)return!0;if(u)return u(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:u}=n;return a===$?this:u?u(d,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return gt("isCompressed",a),this.assertValidity(),s(d,this,a)}toHex(a=!0){return gt("isCompressed",a),wt(this.toRawBytes(a))}}d.BASE=new d(n.Gx,n.Gy,e.ONE),d.ZERO=new d(e.ZERO,e.ONE,e.ZERO);const v=n.nBitLength,q=Xe(d,n.endo?Math.ceil(v/2):v);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:i,weierstrassEquation:f,isWithinCurveOrder:c}}function nn(t){const n=pe(t);return bt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function rn(t){const n=nn(t),{Fp:e,n:r}=n,s=e.BYTES+1,o=2*e.BYTES+1;function f(m){return Z(m,r)}function c(m){return Vt(m,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:l,weierstrassEquation:h,isWithinCurveOrder:w}=en({...n,toBytes(m,E,p){const _=E.toAffine(),R=e.toBytes(_.x),H=P;return gt("isCompressed",p),p?H(Uint8Array.from([E.hasEvenY()?2:3]),R):H(Uint8Array.from([4]),R,e.toBytes(_.y))},fromBytes(m){const E=m.length,p=m[0],_=m.subarray(1);if(E===s&&(p===2||p===3)){const R=G(_);if(!yt(R,$,e.ORDER))throw new Error("Point is not on curve");const H=h(R);let C;try{C=e.sqrt(H)}catch(K){const F=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+F)}const V=(C&$)===$;return(p&1)===1!==V&&(C=e.neg(C)),{x:R,y:C}}else if(E===o&&p===4){const R=e.fromBytes(_.subarray(0,e.BYTES)),H=e.fromBytes(_.subarray(e.BYTES,2*e.BYTES));return{x:R,y:H}}else throw new Error(`Point of length ${E} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),d=m=>wt(ot(m,n.nByteLength));function v(m){const E=r>>$;return m>E}function q(m){return v(m)?f(-m):m}const y=(m,E,p)=>G(m.slice(E,p));class a{constructor(E,p,_){this.r=E,this.s=p,this.recovery=_,this.assertValidity()}static fromCompact(E){const p=n.nByteLength;return E=U("compactSignature",E,p*2),new a(y(E,0,p),y(E,p,2*p))}static fromDER(E){const{r:p,s:_}=Q.toSig(U("DER",E));return new a(p,_)}assertValidity(){rt("r",this.r,$,r),rt("s",this.s,$,r)}addRecoveryBit(E){return new a(this.r,this.s,E)}recoverPublicKey(E){const{r:p,s:_,recovery:R}=this,H=A(U("msgHash",E));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");const C=R===2||R===3?p+n.n:p;if(C>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=R&1?"03":"02",J=i.fromHex(V+d(C)),K=c(C),F=f(-H*K),Et=f(_*K),tt=i.BASE.multiplyAndAddUnsafe(J,F,Et);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return v(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,f(-this.s),this.recovery):this}toDERRawBytes(){return mt(this.toDERHex())}toDERHex(){return Q.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return mt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const u={isValidPrivateKey(m){try{return l(m),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const m=Ee(n.n);return Ge(n.randomBytes(m),n.n)},precompute(m=8,E=i.BASE){return E._setWindowSize(m),E.multiply(BigInt(3)),E}};function g(m,E=!0){return i.fromPrivateKey(m).toRawBytes(E)}function b(m){const E=ft(m),p=typeof m=="string",_=(E||p)&&m.length;return E?_===s||_===o:p?_===2*s||_===2*o:m instanceof i}function B(m,E,p=!0){if(b(m))throw new Error("first arg must be private key");if(!b(E))throw new Error("second arg must be public key");return i.fromHex(E).multiply(l(m)).toRawBytes(p)}const O=n.bits2int||function(m){const E=G(m),p=m.length*8-n.nBitLength;return p>0?E>>BigInt(p):E},A=n.bits2int_modN||function(m){return f(O(m))},x=Dt(n.nBitLength);function S(m){return rt(`num < 2^${n.nBitLength}`,m,D,x),ot(m,n.nByteLength)}function I(m,E,p=j){if(["recovered","canonical"].some(st=>st in p))throw new Error("sign() legacy options not supported");const{hash:_,randomBytes:R}=n;let{lowS:H,prehash:C,extraEntropy:V}=p;H==null&&(H=!0),m=U("msgHash",m),ie(p),C&&(m=U("prehashed msgHash",_(m)));const J=A(m),K=l(E),F=[S(K),S(J)];if(V!=null&&V!==!1){const st=V===!0?R(e.BYTES):V;F.push(U("extraEntropy",st))}const Et=P(...F),tt=J;function Rt(st){const at=O(st);if(!w(at))return;const Xt=c(at),lt=i.BASE.multiply(at).toAffine(),Y=f(lt.x);if(Y===D)return;const ut=f(Xt*f(tt+Y*K));if(ut===D)return;let Qt=(lt.x===Y?0:2)|Number(lt.y&$),Jt=ut;return H&&v(ut)&&(Jt=q(ut),Qt^=1),new a(Y,Jt,Qt)}return{seed:Et,k2sig:Rt}}const j={lowS:n.lowS,prehash:!1},T={lowS:n.lowS,prehash:!1};function N(m,E,p=j){const{seed:_,k2sig:R}=I(m,E,p),H=n;return ge(H.hash.outputLen,H.nByteLength,H.hmac)(_,R)}i.BASE._setWindowSize(8);function z(m,E,p,_=T){var lt;const R=m;if(E=U("msgHash",E),p=U("publicKey",p),"strict"in _)throw new Error("options.strict was renamed to lowS");ie(_);const{lowS:H,prehash:C}=_;let V,J;try{if(typeof R=="string"||ft(R))try{V=a.fromDER(R)}catch(Y){if(!(Y instanceof Q.Err))throw Y;V=a.fromCompact(R)}else if(typeof R=="object"&&typeof R.r=="bigint"&&typeof R.s=="bigint"){const{r:Y,s:ut}=R;V=new a(Y,ut)}else throw new Error("PARSE");J=i.fromHex(p)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(H&&V.hasHighS())return!1;C&&(E=n.hash(E));const{r:K,s:F}=V,Et=A(E),tt=c(F),Rt=f(Et*tt),st=f(K*tt),at=(lt=i.BASE.multiplyAndAddUnsafe(J,Rt,st))==null?void 0:lt.toAffine();return at?f(at.x)===K:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:B,sign:N,verify:z,ProjectivePoint:i,Signature:a,utils:u}}function on(t,n){const e=t.ORDER;let r=D;for(let q=e-$;q%et===D;q/=et)r+=$;const s=r,o=et<<s-$-$,f=o*et,c=(e-$)/f,i=(c-$)/et,l=f-$,h=o,w=t.pow(n,c),d=t.pow(n,(c+$)/et);let v=(q,y)=>{let a=w,u=t.pow(y,l),g=t.sqr(u);g=t.mul(g,y);let b=t.mul(q,g);b=t.pow(b,i),b=t.mul(b,u),u=t.mul(b,y),g=t.mul(b,q);let B=t.mul(g,u);b=t.pow(B,h);let O=t.eql(b,t.ONE);u=t.mul(g,d),b=t.mul(B,a),g=t.cmov(u,g,O),B=t.cmov(b,B,O);for(let A=s;A>$;A--){let x=A-et;x=et<<x-$;let S=t.pow(B,x);const I=t.eql(S,t.ONE);u=t.mul(g,a),a=t.mul(a,a),S=t.mul(B,a),g=t.cmov(u,g,I),B=t.cmov(S,B,I)}return{isValid:O,value:g}};if(t.ORDER%se===At){const q=(t.ORDER-At)/se,y=t.sqrt(t.neg(n));v=(a,u)=>{let g=t.sqr(u);const b=t.mul(a,u);g=t.mul(g,b);let B=t.pow(g,q);B=t.mul(B,b);const O=t.mul(B,y),A=t.mul(t.sqr(B),u),x=t.eql(A,a);let S=t.cmov(O,B,x);return{isValid:x,value:S}}}return v}function sn(t,n){if(we(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=on(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,o,f,c,i,l,h,w;s=t.sqr(r),s=t.mul(s,n.Z),o=t.sqr(s),o=t.add(o,s),f=t.add(o,t.ONE),f=t.mul(f,n.B),c=t.cmov(n.Z,t.neg(o),!t.eql(o,t.ZERO)),c=t.mul(c,n.A),o=t.sqr(f),l=t.sqr(c),i=t.mul(l,n.A),o=t.add(o,i),o=t.mul(o,f),l=t.mul(l,c),i=t.mul(l,n.B),o=t.add(o,i),h=t.mul(s,f);const{isValid:d,value:v}=e(o,l);w=t.mul(s,r),w=t.mul(w,v),h=t.cmov(h,f,d),w=t.cmov(w,v,d);const q=t.isOdd(r)===t.isOdd(w);return w=t.cmov(t.neg(w),w,q),h=t.div(h,c),{x:h,y:w}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function cn(t){return{hash:t,hmac:(n,...e)=>de(t,n,$e(...e)),randomBytes:le}}function fn(t,n){const e=r=>rn({...t,...cn(r)});return Object.freeze({...e(n),create:e})}const an=G;function nt(t,n){if(pt(t),pt(n),t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function ln(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function pt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function un(t,n,e,r){W(t),W(n),pt(e),n.length>255&&(n=r(P(Nt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:o}=r,f=Math.ceil(e/s);if(e>65535||f>255)throw new Error("expand_message_xmd: invalid lenInBytes");const c=P(n,nt(n.length,1)),i=nt(0,o),l=nt(e,2),h=new Array(f),w=r(P(i,t,l,nt(0,1),c));h[0]=r(P(w,nt(1,1),c));for(let v=1;v<=f;v++){const q=[ln(w,h[v-1]),nt(v+1,1),c];h[v]=r(P(...q))}return P(...h).slice(0,e)}function dn(t,n,e,r,s){if(W(t),W(n),pt(e),n.length>255){const o=Math.ceil(2*r/8);n=s.create({dkLen:o}).update(Nt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(nt(e,2)).update(n).update(nt(n.length,1)).digest()}function ce(t,n,e){bt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:o,hash:f,expand:c,DST:i}=e;W(t),pt(n);const l=typeof i=="string"?Nt(i):i,h=r.toString(2).length,w=Math.ceil((h+s)/8),d=n*o*w;let v;if(c==="xmd")v=un(t,l,d,f);else if(c==="xof")v=dn(t,l,d,s,f);else if(c==="_internal_pass")v=t;else throw new Error('expand must be "xmd" or "xof"');const q=new Array(n);for(let y=0;y<n;y++){const a=new Array(o);for(let u=0;u<o;u++){const g=w*(u+y*o),b=v.subarray(g,g+w);a[u]=Z(an(b),r)}q[y]=a}return q}function hn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[o,f,c,i]=e.map(l=>l.reduce((h,w)=>t.add(t.mul(h,r),w)));return r=t.div(o,f),s=t.mul(s,t.div(c,i)),{x:r,y:s}}}function gn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,s){const o=ce(r,2,{...e,DST:e.DST,...s}),f=t.fromAffine(n(o[0])),c=t.fromAffine(n(o[1])),i=f.add(c).clearCofactor();return i.assertValidity(),i},encodeToCurve(r,s){const o=ce(r,1,{...e,DST:e.encodeDST,...s}),f=t.fromAffine(n(o[0])).clearCofactor();return f.assertValidity(),f},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const o of r)if(typeof o!="bigint")throw new Error(`mapToCurve: expected array of bigints, got ${o} in array`);const s=t.fromAffine(n(r)).clearCofactor();return s.assertValidity(),s}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),It=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Bt=BigInt(1),_t=BigInt(2),fe=(t,n)=>(t+n/_t)/n;function Be(t){const n=xt,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),f=BigInt(23),c=BigInt(44),i=BigInt(88),l=t*t*t%n,h=l*l*t%n,w=M(h,e,n)*h%n,d=M(w,e,n)*h%n,v=M(d,_t,n)*l%n,q=M(v,s,n)*v%n,y=M(q,o,n)*q%n,a=M(y,c,n)*y%n,u=M(a,i,n)*a%n,g=M(u,c,n)*y%n,b=M(g,e,n)*h%n,B=M(b,f,n)*q%n,O=M(B,r,n)*l%n,A=M(O,_t,n);if(!it.eql(it.sqr(A),t))throw new Error("Cannot find square root");return A}const it=ye(xt,void 0,void 0,{sqrt:Be}),$t=fn({a:BigInt(0),b:BigInt(7),Fp:it,n:It,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=It,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Bt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,f=BigInt("0x100000000000000000000000000000000"),c=fe(o*t,n),i=fe(-r*t,n);let l=Z(t-c*e-i*s,n),h=Z(-c*r-i*o,n);const w=l>f,d=h>f;if(w&&(l=n-l),d&&(h=n-h),l>f||h>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:w,k1:l,k2neg:d,k2:h}}}},St),ve=BigInt(0),ae={};function Ot(t,...n){let e=ae[t];if(e===void 0){const r=St(Uint8Array.from(t,s=>s.charCodeAt(0)));e=P(r,r),ae[t]=e}return St(P(e,...n))}const Gt=t=>t.toRawBytes(!0).slice(1),zt=t=>ot(t,32),kt=t=>Z(t,xt),vt=t=>Z(t,It),Wt=$t.ProjectivePoint,wn=(t,n,e)=>Wt.BASE.multiplyAndAddUnsafe(t,n,e);function Pt(t){let n=$t.utils.normPrivateKeyToScalar(t),e=Wt.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:vt(-n),bytes:Gt(e)}}function xe(t){rt("x",t,Bt,xt);const n=kt(t*t),e=kt(n*t+BigInt(7));let r=Be(e);r%_t!==ve&&(r=kt(-r));const s=new Wt(t,r,Bt);return s.assertValidity(),s}const ht=G;function Se(...t){return vt(ht(Ot("BIP0340/challenge",...t)))}function mn(t){return Pt(t).bytes}function yn(t,n,e=le(32)){const r=U("message",t),{bytes:s,scalar:o}=Pt(n),f=U("auxRand",e,32),c=zt(o^ht(Ot("BIP0340/aux",f))),i=Ot("BIP0340/nonce",c,s,r),l=vt(ht(i));if(l===ve)throw new Error("sign failed: k is zero");const{bytes:h,scalar:w}=Pt(l),d=Se(h,s,r),v=new Uint8Array(64);if(v.set(h,0),v.set(zt(vt(w+d*o)),32),!Ae(v,r,s))throw new Error("sign: Invalid signature produced");return v}function Ae(t,n,e){const r=U("signature",t,64),s=U("message",n),o=U("publicKey",e,32);try{const f=xe(ht(o)),c=ht(r.subarray(0,32));if(!yt(c,Bt,xt))return!1;const i=ht(r.subarray(32,64));if(!yt(i,Bt,It))return!1;const l=Se(zt(c),Gt(f),s),h=wn(f,i,vt(-l));return!(!h||!h.hasEvenY()||h.toAffine().x!==c)}catch{return!1}}const vn=(()=>({getPublicKey:mn,sign:yn,verify:Ae,utils:{randomPrivateKey:$t.utils.randomPrivateKey,lift_x:xe,pointToBytes:Gt,numberToBytesBE:ot,bytesToNumberBE:G,taggedHash:Ot,mod:Z}}))(),bn=(()=>hn(it,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),En=(()=>sn(it,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:it.create(BigInt("-11"))}))(),Ie=(()=>gn($t.ProjectivePoint,t=>{const{x:n,y:e}=En(it.create(t[0]));return bn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:it.ORDER,m:1,k:128,expand:"xmd",hash:St}))(),xn=(()=>Ie.hashToCurve)(),Sn=(()=>Ie.encodeToCurve)();export{Sn as encodeToCurve,xn as hashToCurve,vn as schnorr,$t as secp256k1};
